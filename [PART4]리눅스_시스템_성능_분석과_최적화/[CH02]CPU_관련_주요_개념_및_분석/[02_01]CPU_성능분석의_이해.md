## [02_01] CPU 성능분석의 이해

### 성능 분석 시작은 CPU에서 부터
- CPU는 **모든 소프트웨어 실행을 담당**
  - 성능 분석 시 가장 먼저 봐야하는 대상
- CPU는 모든 실행이 필요한 프로세스가 사용
  - CPU 코어 개수 < Process 개수
    - 대기열에 들어가서 **순서를 기다려야 함**
  - **프로세스 스케줄러**가 순서를 정함
  - `O(1)` 스케줄러는 `Queue`를 이용해 순서를 관리
  - `CFS` 스케줄러는 `Tree`를 이용해 순서 관리 

#### O(1) 스케줄러
- 액티브/만료 큐 관리
- 액티브 큐에 `time slice`동안 프로세스 실행
  - 남은 작업은 **만료 큐**로 이동
- 액티브 큐 수행 완료 후 **만료 큐**를 **액티브 큐**로 변경
  - 프로세스 실행
- kernel v2.4 미만

#### CFS 스케줄러
- 가상 런타임(프로세스 실행 시간)을 관리
- 가상 런타임이 가장 적은 프로세스를
  - 정해진 시간(time slice)동안 실행
- kernel v2.5 이상

### 주요 용어 및 개념

#### 클럭 속도
- CPU는 **클럭 속도**에 따라 명령 실행
- **전력 소모**를 위해 클럭 속도 조절 가능
  - e.g. x86 -> p-state
    - c.f. p0가 가장 빠른 속도
  - e.g. arm(스마트폰) -> DVFS
- 클라우드 환경
  - **일부 인스턴스 타입**에 대해서만 조정 기능 지원
  - 기본 `p-state=0`, 별도로 조정할 이유가 제한적
    - 과금은 `클럭 기준`이 아니라 **시간 단위**이기 때문

#### 하이퍼스레딩(Intel)
- AMD에서는 `SMT`라고 함(Simultaneous MultiThreading)
- 각 물리코어에 **둘 이상의 스레드**를 실행시키도록 지원하는 기술
  - 더 많은 작업을 **병렬 수행** 가능(최대 30%이상 성능 개선)
- 단, 프로세스 구조에 최적화되지 않은 코드의 경우 
  - 성능이 떨어질 수 있음
- OS 입장
  - `2core 4thread -> 4core로 인식, 스케줄링 가능`
- 클라우드 환경
  - `vCPU`는 **물리 CPU**코어의 하이퍼스레드
  - e.g. `r4.2xlarge = vCPU8` <- 물리 코어 4, 논리적 프로세스 8개

#### CPU의 한계
- 물리적인 한계/전력 효율 등의 원인으로
  - `클럭 속도 증가`의 한계 존재
- 2022.07 기준, AWS의 가장 빠른 클럭 속도
  - X2iezn 인스턴스 기준 최대 `4.5GHz`
  - c.f. 대부분 EC2 인스턴스는 `3 GHz`
- 최대 코어 갯수도 제한
  - 물리코어 `1 ~ 64`
- 수직적 확장이 아닌 **수평적 확장**으로 해당 한계 극복

#### 스케줄링 클래스
- 실행 가능 **스레드**의 동작 관리
- **리얼타임 프로세스**
  - 실시간 부하를 위해 고정된 **높은 우선순위** 제공(0 ~ 99)
  - 스케줄링 정책: RR, FIFO
- **일반 프로세스**
  - CFS 스케줄러에 적용할 우선순위 조정(100 ~ 139)
    - 중간값 120(0), `-20 ~ +19`
  - `Completely Fair`지만, **우선순위**에 따라 **실행시간**을 더 할당 받을 수 있음
  - 스케줄링 정책: NORMAL, BATCH
- 우선순위 정보 확인 방법
  ```bash
  ps -el
  ```
- 사용자 프로세스는
  - **일반 클래스**
  - 대부분 동일한 우선순위 `NICE 0`

### 사용률
- 특정 기간동안 CPU 인스턴스가 **작업을 수행한 전체 시간의 백분율**
  - 어떤 cpu가 ps를 실행하거나, interrupt를 처리하는데 걸리는 시간 측정
  - interrupt
    - hw가 ps에 신호를 보내서 적합한 처리를 하도록 요청(polling x)
    - e.g. 키보드 입력, disk에서 데이터 읽기, 네트워크 패킷 도착
- 높은 cpu 사용률이 꼭 문제가 되지는 x
  - 낮은 cpu 사용률은 자원 낭비
  - **급격히 증가하는 cpu 사용 패턴은 반드시 확인**
- 100% 사용률
  - 다른 자원의 **포화상태** 보다는 critical 정도가 낮음
    - memory, disk에 비해 critical한 정도가 낮다는 의미
  - 사용률이 높지 않은 프로세스도 여전히 실행
  - BUT 특정 인스턴스의 경우(e.g. T-Type) 급격한 성능 저하 발생
    - e.g. credit를 다 쓴 경우

### 사용자 시간/커널 시간
- 사용자 시간
  - 사용자 공간 코드를 실행하는데 **CPU가 소비한 시간**
- 커널 시간
  - 커널 공간 코드를 실행하는데 **CPU가 소비한 시간**
- 계산 중심 어플리케이션에서는
  - `사용자/커널 시간 = 99/1`에 가까움
- `I/O`중심 어플리케이션에서는
  - **커널 시간의 비중이 높음**
  - e.g. web server -> `70/30`
    - 네트워크 관련 작업이 많기 때문
