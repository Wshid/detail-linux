## [02_03] CPU 성능분석 도구

### CPU 분석 도구
- 기본 설치
  - **`top`**: 프로세스/스레드별로 CPU 사용 정보 확인
  - `ps`: 프로세스 상태 확인
  - **`uptime`**: 부하 평균 표시
  - **`vmstat`**: 가상 메모리 통계 표시
    - 시스템 전체 CPU 사용률 평균 포함
  - **`pidstat`**: ps/thread별로 cpu 사용을 구분해 표시
  - `time`: 명령 실행에 걸린 시간을 측정, cpu 사용 시간도 별도로 표시
- 추가 패키지
  - `mpstat`: cpu별 통계
  - `sar`: 과거 통계
  - `DTrace`: CPU 프로파일링과 트레이싱
  - **`perf`**: CPU 성능 카운터 분석

### CPU 분석 도구 상세

#### top
- ps/thread별로 cpu 사용 정보 확인
  - 가장 많이 실행중인 ps 표시 -> **CPU 사용률 내림차순**
  - **us**: 사용자 모드에서 실행한 시간
  - **sy**: 커널 모드에서 실행 시간
  - nice: 우선 순위가 조정된 사용자 프로세스 실행 시간
  - id: idle 시간
  - **wa**: `I/O` 완료를 기다리며 아무것도 실행하지 않은 시간(**I/O wait**)
    - e.g. CPU는 일을 안하는데 IO는 일하는 경우
    - IO때문에 delay가 존재한다는 것 확인 가능
  - hi: 하드웨어 인터럽트 처리에 사용된 시간
  - si: 소프트웨어 인터럽트 처리에 사용된 시간
    - 트랩 또는 예외
    - e.g. 존재하지 않은 메모리 주소 접근, 0으로 나누기
  - st: 하이퍼바이저에 의해 빼앗긴 시간
- 주의 사항
  - overhead가 높음
    - `/proc`의 모든 프로세스 노드에 대해 `open/read/close` 수행
  - 단기간만 짧게 실행되는 프로세스는 표시 안될 수 있음
    - default: 3s, `d`키로 시간 조정 가능
    - `d`누르고 `1` -> 1초 단위 조정
- 실습 테스트
  ```bash
  # stress-ng 는 설치 필요
  stress-ng --cpu 3 # 일반 작업은 유저단 작업, us 지표 증가 확인
  stress-ng --io # io 작업은 커널단 작업, sy 지표 증가 확인
  ```

#### uptime
- 시스템 부하 평균을 표시하는 도구
  - cpu 자원의 1m, 5m, 15m 평균 부하 표시
    - **15m의 평균 부하 경향을 볼 수 있음**
    - c.f. `top`의 경우 지속 갱신을 통한 현재 상태 확인
  - 부하 -> 실행중 / 인터럽트 불가능 상태의 프로세스 평균 개수
- 주의 사항
  - 인터럽트 불가능 상태(e.g. disk I/O를 기다림)를 포함
    - **CPU 수요와 디스크 부하를 구분하기 힘듦**
- 실습 테스트
  ```bash
  # uptime 명령을 3초마다 갱신
  watch -n 3 uptime
  stress-ng --cpu 4 # load average의 증가 확인
  ```

#### vmstat
- 가상 메모리 통계를 표시하는 도구
  - **시스템 전체 CPU 사용률**을 같이 표시
  - `r`: 실행/대기 중인 프로세스 개수
  - `b`: 인터럽트 불가능 상태의 프로세스 개수
  - `us`: 사용자 시간
  - `sy`: 시스템(커널) 시간
  - `id`: idle
  - `wa`: I/O wait
  - `st`: 하이퍼 바이저가 뺏어간 시간
- 주의 사항
  - uptime 대비 **인터럽트 불가능 상태**의 프로세스 정보도 포함
  - **프로세스 전체 평균**만을 표시
    - c.f. `mpstat`은 CPU별 통계 표시
- 실습 테스트
  ```bash
  vmstat 1 # 1초마다 추가
  stress-ng --cpu 4 # us의 증가량 확인

  # CPU별 확인, 설치 필요
  mpstat -P ALL 1
  ```

#### pidstat
- **프로세스, 스레드**별로 CPU 사용을 구분해 표시
  - uptime, vmstat은 cpu별 정보 표시
- CPU에서 실행중인 프로세스를 매초 표시
  ```bash
  pidstat 1 # 프로세스별로 어떤 cpu가 쓰였는지도 확인 가능
  stress-ng --cpu 6
  ```

#### perf
- 리눅스 커널 성능 측정 도구
  - CPU 성능 카운터 분석
- 실습 테스트
  ```bash
  # perf, 설치 필요, sudo 필요
  sudo perf stat stress-ng --cpu 3
  # 이후 ctrl+C로 종료후, console 확인
  ```
  - `context-switches`, `page-faults` 등의 상세 정보 확인 가능

### 클라우드 환경에서의 실습
- T-Type Instance는 CPU 테스트 용도로 받지 않음
  - `t2.micro`
- T-Type 인스턴스(=버스트 가능 성능 인스턴스)
  - 기본 수준의 CPU 성능과 더불어 **기본 수준 이상으로 버스트**할 수 있는 기능 제공
  - 범용적인 워크로드는 CPU를 항상 많이 사용하지는 않음
- CPU Credit 범위 내에서 더 많은 CPU를 쓸 수 있음
  - CPU Credit이 없는 경우 baseline 성능으로 성능 저하
  - 해결방법? **인스턴스 변경 또는 무제한 모드**

#### 토큰 버킷 알고리즘 이용
- 버켓에 credit이 남아있는 한도 내에서는 제한 x
- 버켓이 비어있으면 Throttling 걸림
- 기본적으로 버켓은 **일정한 크기**로 채워짐
- 무한정 채워지지 않음 -> 최대값 존재
- 이 특성에 의해 T-Type 인스턴스는 성능이 뚝 떨어지는 상황이 발생하기 때문


### 정리
- CPU 성능 분석을 위한 다양한 리눅스 도구 존재
  - top, ps, uptime, vmstat, pidstat, perf
- 각 도구의 표시 내용 이해 필요
- 각 툴이 대응하는 시나리오 존재
  - top: 현 시점의 사용량
  - uptime: 최근 15분간 **CPU 사용률의 경향성** 파악
  - vmstat: **시스템 전체의 CPU 사용률** 파악
  - pidstat: **프로세스/스레드별로 CPU 사용률**을 파악
- **도구를 조합해서 사용 필요**