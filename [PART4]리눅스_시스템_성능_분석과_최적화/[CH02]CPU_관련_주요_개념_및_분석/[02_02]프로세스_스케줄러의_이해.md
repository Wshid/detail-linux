## [02_02] 프로세스 스케줄러의 이해

### 프로세스 스케줄러
- 실행 중인 프로세스에 프로세서 **동작 시간을 분배**
  - `timeslice`: 프로세스가 선점되기 전까지 주어지는 작업 시간(시간을 나눈다는 뜻)
- **프로세스 실행 순서**를 결정

### 리눅스의 프로세스 스케줄러
- 리눅스 kernel 2.5버전에서는 `O(1) Scheduler` 사용
- 우선순위별로 queue를 구성
- Active Queue task 실행
  - 실행한 작업은 `Expired Queue`로 이동
  - 자신의 timeslice를 모두 사용하였을 경우 이동(다 처리가 되지 않았더라도)
- `Expired Queue`를 `Active Queue`로 변경
- `Acive Queue` task 수행

### CFS Scheduler의 동작
- 다음 실행할 프로세스 선택
  - virtual runtime: ps가 실행한 시간
    ```bash
    VR(T) = PR(T, 실제 수행시간, 이전 수행시간) * Weight0 / Weight(T, 우선순위)
    ``` 
    - 우선순위와 VR(T)는 반비례 관계
  - virtual runtime을 red-black tree로 관리
  - 우선순위를 고려하여 **실행 시간**을 계산
- 실행 시간
  - 스케줄링 기간(default: 100ms)을 가중치 기반으로 할당
    ```bash
    TS(T) = P(전체 실행 시간) * 현재 Weight(T) / 전체 가중치의 합
    ```
    - 가중치가 높을수록 많은 시간을 할당 받음
- Q) ps 수가 무한이 늘어날 경우, 공평하게 시간을 나누면 실행 시간이 `0`에 가까워지지 않을까?
  - 개별 `ps`에 할당하는 `min timeslice`값이 존재

### CFS는 O(1)의 대화형 성능을 개선하는가?
- e.g. 문서 편집기, 동영상 인코더 두가지 작업이 있는 시스템
- 문서 편집기는, 대부분의 시간을 `사용자 키 입력`을 기다리는데 사용
  - IO 중심 ps
- 동영상 인코더는 데이터 로드/저장 제외하고 **대부분의 시간을 프로세서**를 사용
  - CPU 중심
- 매뉴얼한 해결 방법
  - **문서 편집기**에 더 높은 우선순위, 긴 timeslice 할당
- 하지만, linux에서는 일반적으로
  - `사용자 ps에 동일한 우선순위를 부여`

#### CFS 스케줄러 정책
- **가중치**와 **이전 실행시간**을 고려해
  - 다음 실행 시간을 산정하여 **공평하게 실행 시간**을 나눔
- 가중치(=우선순위)가 같아도 **이전 실행시간**이 다름
- 동영상 인코더는 쉬지않고 CPU를 사용했기 때문에 큰 `Virtual Runtime`을 가짐
- 문서 편집기는 대부분의 시간을 `IO 요청 대기`에 사용하기 때문에 낮은 `Virtual Runtime`
- **문서 편집기**의 반응성 유지 가능
