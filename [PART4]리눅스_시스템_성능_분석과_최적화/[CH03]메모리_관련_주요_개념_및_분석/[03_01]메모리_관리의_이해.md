## [03_01] 메모리 관리의 이해
- 리눅스의 메모리 관리

### 물리 메모리 vs 가상 메모리
- 물리 메모리
  - 실질적으로 사용할 수 있는 메모리 공간
    - e.g. t2.micro: 1G, t2.2xlarge: 32G
- 가상 메모리
  - 프로세스가 바라보는 물리 메모리를 **추상화**한 메모리 공간
  - e.g. 32bit CPU는 ps별 `2^32 * 1B = 4GB`
  - e.g. 64bit CPU는 ps별 `2^64 * 1B = 16EB`
    - Intel 64bit CPU 48bit, 256TB
  - 당분간은 프로세스의 가상 메모리 공간 제약은 x

### 페이징
- 가상 메모리, 물리 메모리를 어떻게 사용?
- 가상 메모리, 물리 메모리 공간을 **일정한 조각**으로 나누어 관리
  - 가상 메모리 조각: 페이지
  - 물리 메모리 조각: 페이지 프레임
- 페이지의 크기
  - 4KB, 8KB => 아키텍처에 따라 다름
  - Intel: 4KB
- 가상 메모리의 페이지를 **물리 메모리**의 페이지에 적재/해제
  - 매핑 정보는 **페이지 테이블**에 유지

### 물리 메모리보다 큰 앱이 어떻게 구동되는가
- 2G 물리메모리에 8G를 사용하는 온라인 게임 실행

### 요구 페이징(Demand Paging)
- 모든 데이터를 **메모리**에 로드하지 않고
  - **필요할 때 디스크 페이지를 로드**
  - 물리 메모리의 프로그램의 페이지가 없더라도, 프로그램 실행 가능
  - 제한된 메모리 공간을 최대한 **효율적**으로 사용
- 프로세스가 존재하지 않는 페이지에 접근하면 **Page Fault** 발생
  - 스토리지에서 메모리로 데이터를 다시 로드 후 **페이지 테이블 갱신**
- 디스크에 저장된 데이터가 아니라 프로그램이 `malloc`으로 메모리 공간을 할당하는 경우?
  - `heap`메모리 영역 크기만 증가, 물리 메모리 공간을 사용하지 x
  - 추후, 프로세스가 가상 메모리 영역에 접근하는 경우
    - Page Fault 이후 페이지 할당

### 가상 메모리 - 물리 메모리 매핑 정보 관리

#### 페이지 테이블
- **프로세스의 페이지 매핑정보를 저장**하고 있는 테이블
  - **페이지 넘버 - 페이지 프레임 넘버**
  - 프로세스마다 **별도의 페이지 테이블**을 유지
    - 프로세스별로 **별도 메모리 공간 분리**
- 매번 주소 조회시 페이지 테이블을 확인하는가?
  - `TLB`(Translation Lookahead Buffer)에 캐싱
  - TLB 상태 확인 -> `perf` 툴로 확인 가능

### 프로세스별로 페이지 테이블 유지시, 그 크기는?

#### 페이지 테이블
- 페이지 테이블 크기 계산
  - e.g. 가상 주소공간 32bit * 1B = 4GB
    - page size: 4KB
    - page table entry: 4Bytes
  - `logical address = logical page num + page offset`
    ```bash
    32bits - 12bits(4KB) = 20bits
    2^20 * 4Byte(PTE) = 4MB
    ```
  - 프로세스별로 페이지 테이블 유지
    - e.g. 프로세스 개수 = 100, 100 * 4MB = 400MB
- 페이지 테이블 **관리 효율**을 위해 **다중 계층의 구조**를 가짐
  - 실제 사용하는 메모리에 대해서만 **Page Table Entry**할당

### 요구 페이징을 하더라도, 물리 메모리가 부족한 상황이 발생하게 됨

#### 페이지 교체 알고리즘
- 페이지 부족시, 새로운 페이지 할당을 위해
  - 현재 할당된 페이지중, 어느것과 교체할지를 결정하기
- **LRU**(Least Recently Used)
- **Active**, **Inactive** 리스트 관리(`/proc/meminfo`)
  - `file`: 파일로 존재하는 페이지 -> **페이지 회수**
  - `anon`: 파일로 존재하지 않는 페이지(e.g. stack, heap) -> **스와핑**

#### 스와핑
- 전체 프로세스를 `주 메모리`와 `물리적 swap 장치/file`사이에 이동
- 프로세스가 사용하는 모든 데이터를 `swap`장치에 기록
  - anonymous page 포함
  - file page의 경우, **변경되지 않은 것은 제외**
    - 필요시 원위치에서 읽어옴
- **성능 저하 이슈**로, 성능이 중요한 앱에선 잘 사용하지 x
  - 클라우드에서도 잘 사용하지 x
- **스와핑이 없는 시스템에서 앱에 메모리 누수 발생?**
  - `OOM Killer`가 강제로 ps kill
